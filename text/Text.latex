%\documentclass[oneside,final,12pt]{article}
\documentclass[oneside,final]{article}
\usepackage[14pt]{extsizes}
\usepackage[utf8]{inputenc}
\usepackage[russianb]{babel}
\usepackage{vmargin}
\setpapersize{A4}
\setmarginsrb{2cm}{1.5cm}{1cm}{1.5cm}{0pt}{0mm}{0pt}{13mm}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{subcaption}
\sloppy
\makeatletter
\renewcommand*{\@biblabel}[1]{\hfill#1.}
\makeatother
\begin{document}

\begin{titlepage}
	\centering
		\begin{figure}
			\centering
			\includegraphics[width=0.5\textwidth]{MSU}
		\end{figure}
		{\scshape
		Московский государственный университет\\имени М. В. Ломоносова}\\
		\bigskip
		{\small

		Факультет вычислительной математики и кибернетики\\
		Кафедра автоматизации систем вычислительных комплексов

		}

		\vfill
		Важдаев Александр Сергеевич\\
		\bigskip
		{\bf Стратегия кэширования, использующая разделение кэша
		на основании атрибутов информационных объектов}\\
		\bigskip
		{\scshape\small Выпускная квалификационная работа}\\
		\vfill
		\normalfont
		\begin{flushright}
			{\bf Научный руководитель:}\\математик ЛВК\\А. М. Колосов
		\end{flushright}
		\vfill
		Москва, 2020
\end{titlepage}

\section*{Аннотация}

В работе выдвигается гипотеза о сравнительной
эффективности алгоритма
кэширования, основывающегося на анализе семантических метаданных (атрибутов)
хранимых информационных объектов и временном распределении запросов к кэшу,
строится такой алгоритм и проводится серия экспериментов с целью проверки
этой гипотезы.

\newpage
\tableofcontents

\newpage
\section{Введение и обзор}

Кэширование используется в самых различных системах для оптимизации работы
тех или иных частей~--- начиная с кэш-памяти процессоров и до отдельных
гигантских кэш-серверов в сетях типа CDN.

Как правило, задача кэша заключается в том, чтобы максимально сократить долю
{\it промахов}~--- обращений к такому объекту, который не содержится в кэше.
Для этого нужно наполнять кэш-память подходящими объектами. Подходов к выбору
таких объектов существует достаточно много, причём разные
подходы более эффективны для тех или иных областей применения, чем другие.

Принцип работы конкретной кэширующей системы чаще всего задаётся некоторым
алгоритмом, который называется {\bfseries\itshape стратегией кэширования}.

\bigskip

\subsection{Анализ известных стратегий}

\paragraph{Простейшие стратегии}

Самые простые в реализации, однако, не всегда достаточно эффективные для
применения в реальных системах~--- такие, как, например, LRU
(Least Recently Used) и LFU (Least Frequently Used).
Обычно они основываются на простейшем подсчёте популярности или полезности
объекта: в LRU из кэша удаляется объект, который не запрашивался дольше
всех остальных, в LFU~--- объект, который запрашивался реже остальных.

Эти стратегии часто являются основой для построения других, более сложных
стратегий.

\paragraph{Сегментные кэши}

Как правило, гораздо более эффективные стратегии, но по-прежнему достаточно
простые в реализации. Самый популярный пример~--- SNLRU ($N$-Segmented LRU).
Главная особенность таких стратегий заключается
в {\it сегментировании}~--- разделении кэша на изолированные части.

В случае SNLRU кэш делится на $N$ сегментов, между которыми определённым
образом перемещаются объекты, причём внутри каждого из сегментов используется
стратегия LRU. В этой стратегии сегменты делятся по {\it приоритетности}~---
самым приоритетным считается «верхний» сегмент, в противоположность «нижнему»,
и более приоритетные запросы перемещаются между сегментами «снизу вверх»
(и, соответственно, наоборот), а из самого «нижнего» сегмента объекты удаляются
окончательно. Подобным образом можно организовать сегментирование практически
любой стратегии, но наиболее распространена именно схема с LRU.

\paragraph{TrendLearner}

Одна из нестандартных стратегий, описанная в \cite{trendlearner}. В отличие от
остальных, {\bf не является стратегией общего типа}, то есть подходит лишь
для объектов определённого класса, а не любых вообще.

Основа механизма TrendLearner базируется на {\it атрибутах объектов}~---
некоторой семантической метаинформации, приписанной к объектам. В данном случае
описывается работа механизма для видеохостинга, соответственно, речь идёт об
атрибутах типа «автор видео/режиссёр фильма», «дата премьеры» и~т.~п.

Система кэширования анализирует группы объектов с одинаковыми атрибутами и
производит их кластеризацию, после чего каждому кластеру сопоставляется его
приоритетность, и в кэш сохраняются по возможности объекты с наибольшим
приоритетом.

Главный недостаток конкретно этой системы~--- неприспособленность к изменениям
и не вполне корректная обучаемость. Приоритеты кластеров, вообще говоря, могут
довольно быстро и значительно изменяться, и система обучения не успевает
приспособиться к изменениям.

\paragraph{AdaptSize}

Достаточно простая, но всё же нестандартная стратегия, которая описывается в
\cite{adaptsize}. Довольно очевидная стратегия, основанная на фильтрации
объектов по пороговому значению определённого признака~--- в данном случае, по
размеру объекта. Суть алгоритма: в процессе анализа запросов вычисляется
{\it оптимальный пороговый размер}, после чего в кэш сохраняются только
объекты, не превышающие этого размера.

Эффективность кэша основывается на гипотезе, что маленькие объекты более
требовательны к скорости загрузки: пользователь может подождать несколько
дополнительных секунд, ожидая загрузки двухчасового фильма, но при этом не
готов долго ждать начала воспроизведения 30-секундного ролика.

Недостаток такого подхода в том, что он, вообще говоря, легко может оказаться
неверным~--- какой-либо длинный видеофайл может оказаться настолько популярнее
такого же по размерам множества коротких, что сохранить его, несмотря на
размер, оказалось бы значительно эффективнее.

\paragraph{Абстрактные стратегии}

Для анализа эффективности кэша часто бывает полезно сравнивать разные стратегии
не только друг с другом, но и с некоторым абсолютным (или почти абсолютным)
эталоном. Для этого используются так называемые {\it оптимальные стратегии} или
стратегии {\it с предвидением}. Особенность таких стратегий в том, что им
известны не только запросы, которые уже произошли, но и те, которые произойдут
в будущем. Такие стратегии являются чисто модельной абстракцией, поскольку, по
понятным причинам, не могут существовать в реальности. В качестве примера
можно привести алгоритм Белади \cite{opt},
работающий по следующему правилу: {\it из кэша при необходимости удаляется
объект, который дольше всего не будет запрошен в будущем}.

\bigskip

Разные стратегии кэширования принято сравнивать друг с другом по какому-либо 
показателю,
отражающему качество работы кэша. Часто в роли такого показателя используется
величина {\bf hit rate}~--- соотношение {\it попаданий в кэш} ко всем запросам
в той или иной форме. Ввиду особенностей исходных данных в работе будет
использоваться его разновидность {\bf byte hit rate (BHR)}, что будет
подробно описано далее \cite{facebook}.

Для тестирования кэш-системы, выявления качественных характеристик, иных
показателей применяют {\it симуляцию}: запускается специальная
программа-{\it симулятор}, которая получает на вход {\it историю запросов},
которые затем осуществляются к кэш-системе как если бы это были настоящие
запросы от клиентов.

\bigskip

Предлагаемая в работе система комбинирует несколько вышеописанных подходов и
основывается на идее {\it семантического разделения данных}, то есть, выбор
предпочтений кэша будет основываться на смысловой нагрузке тех или иных
объектов. Это могут быть, к примеру, метаданные сохраняемых файлов, какие-либо
особенности их внутреннего строения и так далее. В дополнение к этому,
система использует {\it сегментный подход} и {\it динамическое разделение
во времени}. Выдвигается гипотеза, что в определённых ситуациях это может дать
улучшение какого-либо качественного показателя системы кэширования.

Основной задачей работы будет построение такого алгоритма и выяснение,
существуют ли такие входные данные, на которых этот алгоритм даст увеличение
качественной характеристики (величины BHR).

\newpage
\section{Описание задачи и начальная гипотеза}

\subsection{Исходные данные}

Для исследования были предоставлены несколько наборов реальных данных,
представляющих
собой историю запросов к нескольким узлам CDN некоторого видеохостинга.
Объекты размечены {\bfseries\itshape атрибутами}~--- некоторыми семантическими
данными (такими как, например, жанр видео, режиссёр фильма и~т.~п.).
Суммарный объём всех данных составляет порядка 10 Гб и включает более
537 тысяч размеченных объектов и историю около 75 миллионов запросов.

\subsection{Мотивы}

Если рассмотреть множество распределений во времени объёма запросов к объектам,
соответствующих определённому атрибуту или множеству атрибутов, в некоторых
из таких распределений можно обнаружить некое подобие {\it периодической
зависимости}. Формально её можно описать как совпадение {\it с некоторой
точностью} количества запросов (либо процентной доли или иной количественной
характеристики) в промежутки времени, отличающиеся на некоторый фиксированный
промежуток. Такую периодическую зависимость далее будем называть
{\bfseries\itshape мотивом}, а атрибуты объектов, образующих такую
зависимость~--- {\bfseries\itshape атрибутами этого мотива}.

%\bigskip

%<Здесь будут диаграммы~--- примеры цикличных распределений>

\subsection{Особенности системы кэширования}

Можно выделить три основных отличительных черты предлагаемой системы:

\begin{itemize}
\item {\bf Сегментирование.} Всё пространство кэша делится на сегменты
определённым образом. Внутри каждого сегмента используется какая-либо
стратегия кэширования так, будто каждый сегмент является самостоятельным
независимым кэшем; при этом каждому сегменту строго соответствует какое-либо
подмножество всех возможных объектов;
\item {\bf Атрибуты.} Каждому сегменту кэша сопоставлен некоторый набор
атрибутов; тогда соответствие объекта тому или иному сегменту определяется по
атрибутам этого объекта;
\item {\bf Мотивы.} Распределение сегментов строится динамически на основе
{\it мотивов}, которые отыскиваются алгоритмом среди поступающих запросов:
обнаруженные циклические зависимости используются для предсказания
возможного распределения запросов по атрибутам в предстоящий момент времени.
\end{itemize}

\subsection{Эксперименты, генератор данных}

Поскольку такая система кэширования, вообще говоря, пригодна к использованию
не только для конкретной ситуации, а вообще для любых размеченных данных,
стоит проверить её работу не только на нескольких конкретных
наборах данных, а и на множестве каких-либо других.

\bigskip

Так как реальных наборов предоставлено всего несколько штук, можно
синтезировать
новые наборы данных на основе существующих. Поскольку точно известны
закономерности в данных, определяющие целесообразность применения новой
системы, можно реализовать {\bfseries\itshape генератор наборов данных},
обладающих такими
закономерностями в той или иной степени. Характер этих закономерностей при
этом будет определяться {\bfseries\itshape параметрами этого генератора}.

С помощью такого генератора можно создать целое множество наборов данных и
определить, при каких параметрах достигается улучшение качественных
показателей разработанного алгоритма кэширования (и достигается ли вообще).

\subsection{План работы}

В общих чертах, план предстоящей работы следующий:

\begin{enumerate}
\item {\bf Построить систему кэширования}, использующую метод сегментирования
на основании мотивов~--- периодических закономерностей в количестве запросов
к объектам, имеющим заданный набор атрибутов;
\item {\bf Построить экспериментальную среду}:
симулятор запросов к кэшу по заданному
набору запросов и генератор таких наборов по некоторым численным параметрам;
\item {\bf Провести тестирование} кэша на построенных наборах данных, сравнить
качественные характеристики получившейся системы с некоторой базовой системой;
\item {\bf Сделать вывод} о применимости гипотезы~---
действительно ли такой подход
может повышать качество кэширования, и, если да, то при каких условиях
(характеристиках алгоритма, параметрах генератора) это достигается.
\end{enumerate}

\newpage
\section{Постановка задачи, определения}

Для формализации вышеописанной системы и постановки задачи
введём базовые определения, на которых будет основываться работа.

\subsection{Объекты и атрибуты}

Главным понятием всей работы является
{\bfseries\itshape информационный объект}.
Будем считать, что фактическая информационная нагрузка объекта не~важна;
достаточно, чтобы объект имел некоторый {\bfseries\itshape идентификатор}~---
элемент
произвольного множества идентификаторов (в~работе в~качестве идентификаторов
используются текстовые строки) такой, чтобы каждый идентификатор был
уникальным для~данного объекта, т.~е., для каждого элемента из множества
идентификаторов существовал ровно один объект с таким идентификатором, а~также
у каждого объекта должен быть задан {\bfseries\itshape размер}~--- некоторое
положительное число.

\bigskip

Также потребуется понятие {\bfseries\itshape атрибута} и
{\bfseries\itshape пространства атрибутов}.
{\bfseries\itshape Пространство атрибутов} подобно множеству идентификаторов:
это пространство
произвольных элементов, для которых важно лишь то, принадлежит элемент этого
пространства некоторому множеству или нет. Подобно идентификаторам, в работе
в качестве пространства атрибутов используется заданное множество текстовых
строк.

\bigskip

Для каждого объекта задаётся
{\bfseries\itshape множество атрибутов объекта}~--- конечное
число элементов из пространства атрибутов. Говорят, что объект обладает
данным атрибутом, если его множество атрибутов содержит этот атрибут.

\bigskip

Таким образом, информационный объект можно задать как тройку
$\omega=\left\{I,\ W,\ \Xi\right\}$, где $I_\omega$~--- идентификатор объекта,
$W_\omega > 0,\ W_\omega\in\mathbb R$~--- размер объекта,
$\Xi_\omega=\left\{\xi_\omega\right\}$~--- атрибуты объекта.

\bigskip

Множество всех заданных объектов обозначим как $\Omega=\left\{\omega\right\}$,
причём верно, что $\forall\omega_1,\omega_2\in\Omega\ \omega_1\not=\omega_2
\Leftrightarrow I_{\omega_1}\not= I_{\omega_2}$, а пространство атрибутов как
$\Xi=\left\{\xi\right\}$.

Множество всех атрибутов с сопоставленными каждому атрибуту объектами будем
называть {\bfseries\itshape таблицей атрибутов}: $\tau:\ \Xi\rightarrow
\left\{\omega_\Xi\right\}$.

\subsection{Кэш и события}

Ещё одним центральным определением является {\bfseries\itshape кэш}.
Кэш понимается
как некоторый объект, для которого задано {\bfseries\itshape состояние кэша}
(далее эти понятия используются как тождественные).

Кэш содержит в себе некоторые объекты, то есть, для кэша необходимо задать
множество объектов, которые в нём содержатся на данный момент.

Поскольку дисковое пространство кэша конечно, для кэша также зададим
{\bfseries\itshape размер кэша}~--- положительное число, такое, что суммарный
размер всех содержащихся в кэше объектов не превосходит этого размера.

\bigskip

Таким образом, кэш задаётся как пара $\mathcal C=\left(\Psi,\ M\right)$, где
$\Psi\subseteq \Omega$~--- объекты кэша, $M>0,\ M\in\mathbb R$~--- размер
кэша, причём $\sum_{\psi\in\Psi}W_\psi\leqslant M$.

Подчёркиваем, что кэш~--- не более чем множество содержащихся объектов и
заданный максимальный размер, для него не заданы какие-либо операции или
правила взаимодействия с иными сущностями.

\bigskip

Независимо от определения кэша вводится понятие {\bfseries\itshape события}.
Итак,
{\bfseries\itshape событие}~---
это пара $\varepsilon=\left(\square,\ t\right)$, где $t\in T$~---
% TODO add acute
{\bfseries\itshape момент времени} из некоторого {\bfseries\itshape временного
пространства};
% TODO add acute
в качестве временного пространства может быть задано любое множество,
для элементов которого определены операции сравнения (т.~е., для
$\forall t_1, t_2\in T$ либо $t_1>t_2$, либо $t_1<t_2$, либо $t_1=t_2$);
это может быть, например, множество натуральных или вещественных чисел, или
некоторое его подмножество; в работе пространство времени задано как множество
целых чисел в диапазоне $\left[0, 2^{32}-1\right]$.
$\square\in\left\{Q\left<\omega\right>, S\left<M\right>\right\}$
называется {\bfseries\itshape операцией события}, где
$Q\left<\omega\right>$~---
{\bfseries\itshape запрос объекта $\omega$}, а $S\left<M\right>$~---
{\bfseries\itshape установка максимального размера $M$}.

\bigskip

{\bf Уточнение:} сами по себе события не несут какой-либо смысловой нагрузки,
это лишь абстрактные обозначения. События не имеют никакой связи с кэшем или
его частями.

\bigskip

Определим {\bfseries\itshape историю событий} как произвольное множество
событий $E=\left\{\varepsilon\right\}$, а также:

\begin{itemize}
\item {\itshape{\bfseries История событий $E$ до момента $t$}
(включительно)}: $E_t\subseteq E:\varepsilon\in E_t\Leftrightarrow
t_\varepsilon\leqslant t$.
\item {\bfseries\itshape История событий $E$ до события $\varepsilon$}:
$E_{\underline\varepsilon}\subseteq E:\forall \tilde\varepsilon \in E\
\tilde\varepsilon\in E_{\underline\varepsilon} \Leftrightarrow
t_{\tilde\varepsilon}<t_\varepsilon$.
\item {\bfseries\itshape История событий $E$ после события $\varepsilon$}:
$E_{\bar\varepsilon}=E_{\underline\varepsilon}\cup\varepsilon$.
\end{itemize}

\bigskip

\subsection{Функции кэширования и оценка кэша}

Поскольку смысл {\it системы кэширования} заключается в том, чтобы, среди
прочего, сохранять объекты и обрабатывать запросы клиента, необходимо задать
некоторые {\it правила} работы такой системы. В нашем случае предполагаемая
работа системы может быть описана примерно следующим образом: на вход
подаётся некоторая история событий, которые обрабатываются согласно
определённому алгоритму, после чего на выходе получается {\it состояние кэша
после обработки этих событий}.

\bigskip

В качестве такого алгоритма зададим {\bfseries\itshape функцию кэширования}
$\mathfrak R:\left(\mathcal C, E\right)\rightarrow\mathcal C'$. То есть,
функция кэширования по заданному начальному состоянию кэша и истории событий
возвращает новое {\it состояние кэша после данной истории событий}.

\bigskip

Определим {\bfseries\itshape состояние кэша после события $\varepsilon$}:
$\mathcal C_\varepsilon =
\mathfrak R\left(\mathcal C,\ E_{\bar\varepsilon}\right)$.

Здесь описанные выше {\it события} приобретают фактический смысл. Во-первых,
будем считать, что для кэш-функции выполняется {\bfseries\itshape
корректность задания размера}: для события $\varepsilon =
\left(S\left<M\right>,\ t\right) \in E$ верно, что
$M_{\mathcal C_\varepsilon} = M$ и $\mathcal C_\varepsilon$ удовлетворяет
определению кэша (т.~е., $\sum_{\psi\in\Psi_{\mathcal C_\varepsilon}}
{W_\psi\leqslant\mathcal C_\varepsilon}$).

\bigskip

Во-вторых, для событий типа «запрос объекта» введём ещё одно понятие~---
{\bfseries\itshape
результат запроса}. Пусть $\mathcal C'$~--- состояние кэша в некоторый момент
времени, $\varepsilon=\left(Q\left<\omega\right>, t\right)$~--- запрос.
Тогда {\bfseries\itshape результат запроса $\varepsilon$ к кэшу
$\mathcal C'$} равен $\delta_{\mathcal C',\varepsilon} =
\left[\omega\in\Psi_{\mathcal C'}\right],\
\delta_{\mathcal C',\varepsilon}\in\left\{
\text{\bf true},\ \text{\bf false}\right\}$.

\bigskip

Рассмотрим частный случай функций кэширования, который потребуется для
дальнейшей работы~--- {\bfseries\itshape сегментные функции кэширования}.

\bigskip

Итак, сегментная функция кэширования~--- это такая функция кэширования
$\mathfrak S\in\left\{\mathfrak R\right\}$, что для $\mathfrak S$ определены
{\bfseries\itshape множество сегментов} $\Sigma_{\mathfrak S}\left(t\right) =
\left\{\sigma_{\mathfrak S}\right\}$ и {\bfseries\itshape истории сегментов}
$\left\{E_\sigma\left(t\right)\right\}$, где $\sigma$~--- {\bf кэш}, причём
$\sum_{\sigma\in\Sigma_{\mathfrak S}}{M_\sigma}\leqslant M_{\mathcal C}$; для
каждого сегмента задана функция кэширования $\mathfrak R_\sigma$; задана
$F:\omega\rightarrow\sigma$~--- {\bfseries\itshape функция выбора сегмента} и
$\mathfrak S$ такова: получается $\Sigma_\mathfrak S\left(t\right)$, затем
вычисляются $\sigma = \mathrm F\left(\omega\right)$ и
$E_\sigma\left(t\right)$, и состояние кэша после события $\varepsilon$ равно:
$\left(\cup_{\sigma\in\Sigma_\mathfrak S}
{\Psi_\sigma\in\mathfrak R_\sigma\left(\sigma,\ E_{\sigma\overline\varepsilon}
\right)},\ M\right)$.

\bigskip

Если для всех сегментов функции $\mathfrak S$ задана одинаковая функция
$\mathfrak R$, то будем называть такую функцию $\mathfrak S$
{\bfseries\itshape основанной на функции $\mathfrak R$} и обозначать
$\mathfrak S\left<\mathfrak R\right>$.

\bigskip

Наконец, самое чёткое определение дадим той функции, на основе которой и будет
строиться вся дальнейшая работа~---
{\bfseries\itshape атрибутивно-сегментная функция кэширования}.

\bigskip

Обозначим как $\mathrm R\left(\Omega\right)$ выбор случайного
$\omega\in\Omega$.

Атрибутивно-сегментная функция кэширования~--- сегментная функция кэширования
$\mathfrak A\in\left\{\mathfrak S\right\}$ такая, что для каждого
$\sigma\in\Sigma_{\mathfrak A}$ заданы $\Xi_\sigma$~--- {\bfseries\itshape
атрибуты сегмента} и функция выбора сегмента задана следующим образом: если
$\exists\sigma:\Psi_\sigma\ni\omega$, то $F\left(\omega\right)=\sigma$, иначе
$\mathrm F\left(\omega\right)=\mathrm R\left(\tilde{\Sigma}\right)$, где
$\tilde\Sigma = \cup_{\sigma\in\Sigma_\mathfrak A:\ 
\Xi_\sigma\subseteq\Xi_\omega,\ \not\exists\tilde\Xi:\ 
\Xi_\sigma\subset\tilde\Xi\subseteq\Xi_\omega} \sigma$.

\bigskip

Для проведения аналитической части работы нужно ввести {\it качественную
характеристику} функции кэширования. В качестве такой характеристики будет
использоваться {\bf BHR (byte hit-rate)}~--- отношение суммарного размера
объектов, запросы к которым «попали в кэш» (т.~е., в момент запроса объекта
он находился в кэше), к суммарному размеру всех запрошенных объектов.
Суммарные размеры считаются с повторениями~--- т.~е., разные запросы к
одинаковым объектам считаются столько раз, сколько они встречаются в истории.

\bigskip

Таким образом, величина BHR будет равна: $$\mathcal B\left(\mathfrak R,
\mathcal C, E\right) = \frac{
\sum_{\varepsilon=\left(Q\left<\omega\right>,\ t\right)\in E:\ 
\delta_{\mathcal C, \varepsilon}=\text{\bf true}}{W_\omega}
}{
\sum_{\varepsilon=\left(Q\left<\omega\right>,\ t\right)\in E}{W_\omega}
}$$.

\newpage
\subsection{Генератор и эксперименты}

Теперь введём необходимые определения для построения экспериментальной среды,
в частности, генератора наборов данных. Как мы описали, генератор по заданным
параметрам (сами параметры в определении никак не уточняются и будут
описаны далее, при построении реализации) возвращает некоторую историю
событий.

\bigskip

Итак, {\bfseries\itshape генератор}~--- функция
$\mathcal G:\tau,\ G\rightarrow \left\{E\right\}$, где $\tau$~--- {\it таблица
атрибутов},
$G=\left\{g\right\}$~--- {\bfseries\itshape параметры генератора}, $E$~---
{\it история событий}.

\bigskip

Как видно из определения, по заданным параметрам может быть сгенерирован не
один набор, а целое множество таких наборов (это будет важно для реализации).
Поэтому в рамках программной
реализации мы будем говорить о {\bfseries\itshape запуске генератора}~---
выборе одного набора из этого множества: $\mathrm R\left(\mathcal G\left(
\tau,\ G\right)\right)$ (или конечной серии таких запусков).

\bigskip

Конечно, главное, что нас интересует~--- не сам генератор или создаваемые им
наборы данных, а {\it показатель BHR}, который получается при обработке
кэш-функцией сгенерированного набора данных.

\bigskip

Определим {\bfseries\itshape серию из $N$ экспериментов для заданных $G$,
$\mathcal G$, $\tau$, $\mathcal C$ и $\mathfrak R$} как множество
$E_N\left<\mathcal G\right>\left(\mathfrak R, \tau, \mathcal C, G\right)
=\left\{\mathcal B\left(\mathfrak R, \mathcal C,
\mathcal G\left(\tau, G\right)\right)\right\}^N,\ \left|E_N\right|=N$.

\bigskip

Поскольку даже на одинаковых параметрах генератор может создать совершенно
разные наборы данных, BHR на этих данных тоже может отличаться. Поэтому для
определения качественной характеристики генератора (BHR на заданных параметрах)
нужно вводить не одно число, а целый промежуток.

\bigskip

Введём {\bfseries\itshape диапазон исходов генератора} как
отрезок $D \left<\mathcal G\right>\left(\mathfrak R, \tau, G\right)
=\left(\underline D,\ \overline D\right)$, где
$\underline D=\lim_{N\rightarrow\infty}\min_{\mathcal B\in E_N\left<
\mathcal G\right>\left(\mathfrak R, \tau, \mathcal C, G\right)}\mathcal B$,
$\overline D=\lim_{N\rightarrow\infty}\max_{\mathcal B\in E_N\left<
\mathcal G\right>\left(\mathfrak R, \tau, \mathcal C, G\right)}\mathcal B$.

\bigskip

Заметим, что всех возможных исходов генератора не более чем счётное
количество, поэтому вышеописанный диапазон указывает, на границы не
непрерывного сегмента или отрезка, а лишь счётного (или даже конечного)
множества.

Проблема в том, что, теоретически, чтобы достоверно определить диапазон
исходов генератора, потребуется бесконечная серия экспериментов. Поскольку
работа носит прикладной характер, такое определение не имеет практического
смысла. Поэтому вместо точного определения диапазона мы будем {\it оценивать
его с некоторой вероятностью}.

\bigskip

Определим {\bfseries\itshape оценку диапазона исходов с вероятностью
$p\in\left[0,\ 1\right]$ и точностью $\varepsilon\geqslant0$} как отрезок
$D_{p,\varepsilon} \left<\mathcal G\right>\left(\mathfrak R,
\tau, \mathcal C, G\right)=\left(\underline D_p,\ \overline D_p\right)$, где
$\underline D_p=\min_{\mathcal B\in E_N\left<\mathcal G\right>\left(
\mathfrak R, \tau, \mathcal C, G\right)}\mathcal B$,
$\overline D_p=\max_{\mathcal B\in E_N\left<\mathcal G\right>\left(
\mathfrak R, \tau, \mathcal C, G\right)}\mathcal B$ и такой, что
$\mathrm P\left(\left|\underline D_p - \underline D\right|\leqslant
\varepsilon,\ \left|\overline D_p - \overline D\right|\leqslant\varepsilon
\right) \geqslant p$. При этом число $\min_{E_N\left<\mathcal G\right>
\left(\mathfrak R,\tau, \mathcal C, G\right)} N$ будем называть
{\bfseries\itshape минимальным числом экспериментов} для такой оценки.

\bigskip

Далее потребуется всё же сделать одно уточнение о природе параметров
генератора: области их определения должны быть {\bf ограничены}.

Тем не менее, для поиска требуемого набора может потребоваться перебор
{\it всех} возможных значений параметров. Однако, если хотя бы один из
параметров представляет собой, например, вещественное число, находящееся даже
в сколь угодно малом промежутке допустимых значений, полный перебор будет
принципиально невозможен (поскольку такое множество будет несчётным).
Поэтому вместо перебора всех возможных значений будет проверяться лишь их
конечное число.

\bigskip

Для дальнейших уточнений потребуется ввести ещё одно промежуточное
определение.

\bigskip

Будем говорить, что генератор $\mathcal G$ обладает {\bfseries\itshape
гладкостью на заданной функции кэширования $\mathfrak R$}, если
$\exists \tau \forall \varepsilon>0,\ \varepsilon\in\mathbb R\ \exists
\delta>0,\ \delta\in\mathbb R:\ \forall G_1, G_2\in\left\{G\right\}
\ \rho\left(G_1, G_2\right)<\delta \Rightarrow$
$$\frac{\left|D\left<\mathcal G\right>\left(\mathfrak R,
\tau, \mathcal C, G_1\right)\cap D\left<\mathcal G\right>\left(
\mathfrak R, \tau, \mathcal C, G_2\right)\right|}
{\left|D\left<\mathcal G\right>\left(\mathfrak R, \tau, \mathcal C,
G_1\right)\cup D\left<\mathcal G\right>\left(\mathfrak R, \tau, \mathcal C,
G_2\right)\right|} > 1 - \varepsilon\text{.}$$

\newpage
\subsection{Постановка задачи}

Введя все определения, можно, наконец, точно определить формальную постановку
задачи:

\begin{enumerate}
\item Для заданной функции кэширования $\mathfrak R$ получить
атрибутивно-сегментную функцию $\mathfrak A\left<R\right>$, разработав для неё
алгоритм
вычисления $\sigma_{\mathfrak A}\left(t\right)$.
\item Для заданной таблицы атрибутов $\tau$ и полученной функции $\mathfrak A$
задать конечное множество наборов $G$ параметров для заданного генератора
$\mathcal G$.
\item Для каждого набора $G$ из заданного множества и заданных $\mathfrak A$,
$\mathfrak R$, $\mathcal G$, $\mathcal C$ и $\tau$ получить оценки
$D_\mathfrak R\left(G\right)=D_{0,99,\ 0,01}\left<\mathcal G\right>
\left(\mathfrak R,\tau,\mathcal C, G\right)$ и
$D_\mathfrak A\left(G\right) = D_{0,99,\ 0,01}\left<\mathcal G\right>
\left(\mathfrak A,\tau, \mathcal C,G\right)$.
\item Определить, существует ли такой набор $G$, что на этом наборе
$\overline D_\mathfrak A\left(G\right) > \overline
D_\mathfrak R\left(G\right)$.
\end{enumerate}

\newpage
\section{Практическая часть. Разработка набора приложений}

Поставленная задача будет решаться путём разработки программного комплекса.

\bigskip

Практическая часть будет состоять из двух основных разделов~---
построение собственно алгоритма (функции) кэширования и кэширующей системы, и
разработка среды для проведения экспериментов.

\bigskip

Начальное исследование данных, подготовка их к обработке и некоторые детали
реализации были проведены с использованием языка программирования Python 3.

Конечный программный комплекс разрабатывается на языке C++17 с использованием
стандартных контейнеров и алгоритмов STL.

\subsection{Описание и формат входных данных}

Данные для моделирования процесса кэширования состоят из двух основных частей:

\begin{enumerate}
\item {\bf Таблица атрибутов.} В таблице указаны атрибуты каждого объекта.
Каждый атрибут имеет форму пары строк «Имя параметра~--- значение параметра»
(например, \verb^LANGUAGE='English'^);
\item {\bf История запросов.} В ней последовательно перечислены запросы, для
каждого из которых указан идентификатор объекта, его размер и время запроса.
\end{enumerate}

\paragraph{Типы данных}

В рамках данной задачи в качестве базовых типов данных используются
(здесь и далее пространство имён {\tt std} считается подключенным):

\begin{itemize}
\item Идентификаторы объектов: строка ({\tt string});
\item Один атрибут объекта: пара строк\\
{\tt typedef pair<string, string> TValuePair;}
\item Множество атрибутов одного объекта:\\
{\tt typedef vector<TValuePair> TObjectAttr;}
\item Таблица атрибутов:\\
{\tt typedef map<string, TObjectAttr> TAttrTable;}
\end{itemize}

\subsection{Разработка алгоритма кэширования}

Система кэширования, основанная на атрибутивном сегментировании, среди
прочих параметров, должна иметь некоторую {\bfseries\itshape базовую стратегию}
(или, в терминах работы, {\it функцию кэширования}). Выбранный алгоритм
используется для перенаправления запросов к выбранному сегменту. Система
построена так, что и внешняя система, и функции кэширования сегментов
(называемые далее {\bfseries\itshape подкэшами}) имеют единый интерфейс, что
позволяет унифицировать многие элементы системы, что особенно актуально для
тестирования модели и проведения экспериментов. Опишем эти детали подробнее.

\subsubsection{Интерфейс кэша и требования к подкэшам}

Любой кэш или подкэш для работы с системой должен обладать двумя основными
интерфейсами: возможность запроса объекта, и возможность изменения размера
(то есть, как и математическая функция кэширования, поддерживать
соответствующие события). Для этого зададим интерфейс следующего вида:

\bigskip
\begin{verbatim}
class ICache{
public:
    virtual bool Get(string id, size_t size, time_t time) = 0;
    virtual void SetSize(size_t newSize) = 0;
};
\end{verbatim}
\bigskip

Здесь результатом функции {\tt Get} будет {\it результат запроса}
соответствующего объекта (т.~е., находился ли объект в кэше в момент, когда
он был запрошен).

\subsubsection{Метод временных слотов}

Проверка наличия мотива для заданного набора атрибутов, по сути, сводится к
анализу формы некоторой кривой, показывающей количество запросов к данному
множеству объектов в момент времени. Очевидно, для проведения анализа эту
кривую необходимо {\it дискретизировать}~--- то есть, поделить на некоторые
фиксированные по величине части, которые станут единицей подсчёта количества
запросов к данным.

\bigskip

% TODO добавить ударение
Для дискретизации кривой числа запросов от времени была создана модель
% TODO добавить ударение
{\bfseries\itshape временных слотов}. Каждый слот представляет собой
независимое хранилище статистической информации, которая далее будет
использоваться для анализа. Набор слотов задаётся двумя параметрами~---
{\bf длиной одного слота} и {\bf количеством слотов}. Их произведение задаёт
периоды потенциальных мотивов: система из $N$ слотов, каждый из которых имеет
длину $t$, может определять мотивы с длиной периода $v: Nt\,\vdots\,v$.

Далее слоты используются следующим образом:
\begin{enumerate}
\item Каждый поступающий запрос отправляется в один из слотов и используется
для обучения системы;
\item В момент смены слотов происходит {\bfseries\itshape пересчёт мотивов}:
очередной слот анализирует историю запросов к нему и возвращает информацию о
мотивах~--- в частности, соответствующие атрибуты, размеры и~т.~п. Далее
подсистема распределения сегментов строит {\it множество сегментов}, опираясь
на эти данные.
\end{enumerate}

\subsubsection{Обработка очередного запроса, хранение истории}

Слот хранит в себе статистические данные о поступивших запросах. Организованы
они следующим образом:
\begin{itemize}
\item Заводится отдельная запись для каждого {\it мотива}~--- множества
атрибутов ({\bf не включая} пустое множество);
\item Эта запись хранит в себе таблицу, в которой для каждого идентификатора
содержится количество запросов к этому объекту;
\item Каждый поступающий запрос на объект распределяется в одну или несколько
таких записей;
\item Записи с мотивами добавляются в реальном времени по мере необходимости.
\end{itemize}

Когда в слот попадает очередной запрос, он добавляется в историю всех мотивов,
под которые он подпадает. Например, если атрибуты некоторого объекта были
равны $\Xi=\left\{A,B,C\right\}$, то он попадёт в историю мотивов
$\left\{A\right\}$, $\left\{B\right\}$, $\left\{C\right\}$,
$\left\{A,B\right\}$, $\left\{A,C\right\}$, $\left\{B,C\right\}$,
$\left\{A,B,C\right\}$.

\bigskip

Упрощённо структуру одной записи-мотива можно описать так:

\begin{verbatim}
typedef map<TObjectAttr, map<string, size_t>> TMotive;
\end{verbatim}

\subsubsection{Подсчёт мотивов}

При смене слота будущий активный слот предоставляет набор {\bfseries\itshape
потенциальных мотивов}, на основании которого будет производиться
сегментирование кэша.

Потенциальный мотив формируется на основании истории запросов, поступивших
во временной слот за все циклы. Основу алгоритма составляет {\it подсчёт объёма
трафика}, поступившего в слот за разные циклы; дополнительно могут применяться
различные улучшения, такие как отсечение по пороговым значениям, сглаживание
пиков, коэффициенты устаревания и~т.~п.

Потенциальный мотив представляет собой пару «набор атрибутов — относительный
размер». Алгоритм вычисления потенциальных мотивов очень простой:

\begin{enumerate}
\item Мотивы сортируются по убыванию (невозрастанию) {\bfseries\itshape
качества мотива} (см.~далее);
\item Выбираются первые несколько мотивов в соответствии с {\bfseries\itshape
правилом отсечения} (см.~далее).
\end{enumerate}

{\it Качество мотива}~--- некоторая численная величина, которая используется
для сравнения различных мотивов между собой. Этот показатель
может быть различным,
причём от выбранного показателя в том числе зависит конечный показатель всего
кэша; в рамках задачи в качестве показателя используется {\bf доля трафика,
соответствующего мотиву среди всего трафика за данный промежуток времени
(слот)}.

{\it Правило отсечения}~--- правило, определяющее, какие из найденных мотивов
попадут в итоговое распределение, а какие будут отброшены; в рамках задачи
используется правило отсечения по двум значениям: {\bf минимальное качество
мотива} и {\bf максимальное количество мотивов}. Эти параметры, наряду с
остальными, задаются при запуске системы.

\bigskip

Размер нового сегмента в рамках данного показателя задаётся как произведение
качества мотива на долю объектов без повторений, входящих в мотив, к доле
всех поступивших объектов ({\it размер сегмента} здесь задаётся как
относительная доля от общего размера кэша).

\subsubsection{Перераспределение сегментов, заполнение данными}

Когда система получает новый набор мотивов, она начинает распределять сегменты
кэша в соответствии с этими мотивами. В представленной версии алгоритм
распределения сегментов устроен следующим образом:

\bigskip

Обозначим текущее множество сегментов $\Sigma$, а полученное множество
потенциальных мотивов~--- $V$, причём сегмент представляет собой тройку
$\sigma=\left(\Xi_\sigma, M_\sigma, \Psi_\sigma\right)$, где $\Xi_\sigma$~---
атрибуты сегмента (мотива), $M_\sigma$~--- размер сегмента, $\Psi_\sigma$~---
множество объектов, содержащихся в сегменте, а мотив~--- пару $v=\left(\Xi_v,
M_v\right)$. Новое множество сегментов, которое будет получено после
перераспределения, обозначим $\Sigma'$.

\begin{enumerate}
\item Если для данного $\sigma\in\Sigma\ \exists v\in V: \Xi_v\subseteq
\Xi_\sigma$, то к нему применяется операция $S\left<M_v\right>$, после чего
$\Sigma'\ni \sigma'=\left(\Xi_v, M_v, \Psi_\sigma'\right)$, где
$\Psi_\sigma'$~--- объекты сегмента после выполнения указанной операции.
\item В противном случае $\sigma\not\in\Sigma'$.
\item Если для данного $v\in V \not\exists \sigma\in\Sigma: \Xi_v\subseteq
\Xi_\sigma$, то $\Sigma'\ni \sigma_v=\left(\Xi_v, M_v,
\mathrm P\left(\Xi_v, M_v\right)\right)$, где $\mathrm P
\left(\Xi, M\right)$~---
{\bfseries\itshape предзагрузка объектов по атрибутам $\Xi$ размером $M$}:
функция, которая по заданным атрибутам получает множество объектов,
обладающих этими атрибутами, таких, что их суммарный размер не превосходит
$M$. Принцип, по которому выбираются эти объекты, зависит от реализации.
\item Далее для всех $\omega: \exists \sigma_1, \ldots, \sigma_n\in\Sigma':
\sigma_1\not=\ldots\not=\sigma_n \omega\in\Psi_{\sigma_1} \ldots
\omega\in\Psi_{\sigma_n}$ выбирается $\sigma_{\max} =
\operatorname{\mathrm{argmax}}_{\sigma\in\Sigma'}
{\lvert\Xi_\sigma\rvert}$ и далее $\Psi_\sigma':=\Psi_\sigma'\setminus\omega
\ \forall\sigma\not=\sigma_{\max}$.
\end{enumerate}

\subsubsection{Общая схема системы}

В целом, схему работы системы можно представить следующим образом:

\begin{enumerate}
\item Поступивший от клиента запрос обрабатывается сегментами: если в одном из
них находится объект, он возвращается клиенту; при этом поступает запрос к
соответствующему сегменту;
\item Если ни в одном сегменте нет запрашиваемого объекта, определяется,
какому сегменту, согласно их атрибутам, он должен находиться, и производится
запрос к этому сегменту (далее сегмент действует согласно своей стратегии);
\item Запрос добавляется в историю текущего временного слота;
\item Если на очередном запросе происходит смена временного слота, из системы
анализа запрашиваются новые мотивы на текущий временной слот;
\item Сегменты кэша перераспределяются в соответствии с полученными мотивами.
\end{enumerate}

Графически схема работы системы приведена на рис.~\ref{scheme}.

\begin{figure}[h]
\centering
\includegraphics[width=0.67\textwidth]{scheme_cropped}
\caption{Схема взаимодействия частей системы кэширования}
\label{scheme}
\end{figure}

\newpage
\subsection{Экспериментальный комплекс}

Среда для проведения экспериментов будет состоять из двух основных частей:
симулятора кэша и генератора данных.

\subsubsection{Симулятор кэша}

Задача симулятора кэша~--- смоделировать заданное множество событий на
заданной кэш-системе (кэш-функции) и вычислить в качестве результата
величину BHR.

Симулятор кэша просто считывает построчно указанный файл с историей событий
и последовательно выполняет запросы к указанным объектам.

\subsubsection{Генератор наборов данных}

Для проведения экспериментов, помимо симулятора, потребуется множество наборов
входных данных.

\paragraph{Параметры генератора}

Исходные данные для генератора задают конкретные мотивы и отдельно параметры
каждого мотива. Для каждого мотива задаются, во-первых, его атрибуты, а,
во-вторых, характер распределения числа запросов во времени.

Полный список поддерживаемых параметров выглядит так:
\begin{itemize}
\item {\bf Период мотива.} Показывает, с какой периодичностью будет встречаться
мотив в наборе данных. Задаётся в единицах времени (напр., 1 неделя);
\item {\bf Длительность мотива.} Задаёт, сколько будет длиться одна итерация
мотива (включая рост и угасание). Задаётся в единицах времени (напр., 3 часа);
\item {\bf Объём трафика мотива.} Задаёт суммарный объём трафика,
соответствующего мотиву, за одну итерацию. Измеряется в единицах объёма
(напр., 10 Гб);
\item {\bf Скорость роста и угасания мотива.} Задаёт, насколько плавно будет
нарастать и спадать плотность трафика мотива. Измеряется в единицах времени
(напр., 1 час~--- это будет время, за которое плотность трафика возрастает с
нуля до максимальной величины, и за столько же он будет постепенно
уменьшаться);
%\item {\bf Доля одинаковых объектов.} Определяет, какой процент объектов будет
%совпадать в соседних итерациях мотива. Задаётся в процентах.
\end{itemize}

Параметры могут задаваться не точечно, а в виде диапазонов~--- на каждой
итерации будет случайным образом выбираться некоторое число из этого
диапазона.

\bigskip

Пример задания одного мотива для генератора:
\begin{verbatim}
[GENRE='Thriller', COUNTRY='USA']
period = 1w ; период: 1 неделя
length = 3h~4h ; длительность: 3–4 часа
shift = 1h ; сдвиг от начальной точки отсчёта
volume = 10G ; объём трафика: 10 Гбайт
attack = 20m~30m ; рост и спад: 20–30 минут
\end{verbatim}
%similar = 60%~70% ; доля одинаковых объектов

В одном файле может быть задано множество мотивов, включая так называемый
{\bfseries\itshape пустой мотив}~--- секцию с пустым множеством атрибутов
\verb^[]^, которая будет соответствовать всем объектам из таблицы.

Генератор последовательно создаёт историю запросов для каждого мотива, после
чего объединяет их в единый конечный файл с общей историей запросов,
упорядоченной по времени.

Запуск генератора включает в себя два входных параметра~--- файл конфигурации и
{\it общее число запросов}, которые будут созданы. В результате запуска
получается файл с историей запросов, который далее используется для запуска
симулятора кэша. 

\paragraph{Реализация генератора}

Поскольку генератор является в каком-то смысле обратной программой к системе
анализа мотивов, в нём можно применить тот же подход для генерации наборов~---
{\it дискретизацию по временным слотам}.

\bigskip

Алгоритм работы такого генератора описывается довольно просто:
\begin{enumerate}
\item Выбираем очередной мотив для текущего слота;
\item Определяем, какой объём данных из этого мотива требуется в данный
временной слот (согласно данной конфигурации);
\item Добавляем в итоговый набор случайные объекты суммарным объёмом не более
этого объёма;
\item Переходим к следующему мотиву текущего слота или первому мотиву
следующего слота.
\end{enumerate}

\begin{figure}[h]
\centering
	\begin{subfigure}[h]{4in}
		\includegraphics[width=1.0\textwidth]{graph/generator_1}
	\end{subfigure}
	\hfill
	\begin{subfigure}[h]{3in}
		\includegraphics[width=1.0\textwidth]{graph/generator_2}
	\end{subfigure}
\caption{Визуализация параметров генератора и процесса дискретизации}
\label{easy}
\end{figure}

%\begin{figure}[h]
%\centering
%\includegraphics[width=0.3\textwidth]{generator_1}
%\caption{Пример дискретизации кривой, описанной в файле конфигурации}
%\end{figure}
При этом есть некоторые особенности наборов, создаваемых таким генератором.

\bigskip

Во-первых, заполнение будет происходить не идеально по заданному размеру, а
лишь приближённо: это связано с тем, что далеко не всегда можно подобрать
множество объектов, в сумме дающих строго заданный объём. Поэтому генератор
устроен так, что суммарный объём объектов лишь {\it не превосходит} заданный,
а не равен ему в точности.

Во-вторых, для лучших результатов желательно выбирать частоту дискретизации
(длину слота) генератора либо равной длине слота системы кэширования, либо
такой, чтобы слот кэша имел длину, кратную длине слота генератора.

\newpage
\section{Практическая часть. Эксперименты}

Для второго, экспериментального, раздела практической части работы будут в
паре использоваться два программных средства~--- симулятор и генератор наборов.

\subsection{Описание экспериментов}

Одна серия экспериментов производится следующим образом:
\begin{enumerate}
\item Проектируется тестируемое распределение запросов и подготавливается
соответствующий конфигурационный файл для генератора наборов данных;
\item Генератор запускается несколько (зависит от типа эксперимента, см.~далее)
раз на этом конфигурационном файле;
\item На полученных наборах данных запускаются последовательно или параллельно
симулятор кэша LRU и симулятор атрибутивно-сегментного кэша {\bf с одинаковым
суммарным размером кэша}; при этом для атрибутивно-сегментного кэша может
производиться несколько запусков на каждом наборе с разными параметрами
алгоритма кэширования (см. Приложение)
с последующим выбором из них лучшего результата;
\item Результатом каждого запуска симулятора является итоговое значение BHR;
\item Сравниваются значения BHR базового и предложенного алгоритма;
положительным
результатом эксперимента считается такой, у которого BHR предложенного
алгоритма выше такового для базового.
\end{enumerate}

\subsubsection{Параметры генератора}

Для создания наборов данных будут использоваться конфигурационные файлы разных
уровней сложности.

Во всех случаях создаваемый набор данных будет иметь размер 1~000~000 запросов.

Частота дискретизации генератора установлена в 15 минут, а параметры слота
алгоритма кэширования подбираются кратно длинам мотивов.

Остальные параметры алгоритма подбираются по возможности оптимальным образом
для достижения наибольшего BHR. Размер кэша выбирается таким образом, чтобы
итоговый BHR находился в пределах 0,20--0,80 (кроме последнего набора данных).

\bigskip

К каждому подразделу также приведены {\bfseries\itshape графики
BHR}, показывающие величину BHR после обработки первых {\sf Rq} запросов
указанного набора данных. На графиках серым цветом обозначен базовый алгоритм
(LRU без сегментирования), а чёрным~--- атрибутивно-сегментный алгоритм.

\subsubsection{Легко разделяемые данные}

Легко разделяемыми данными будем называть такие данные, в которых каждый
временной слот на 100\% занят данными ровно одного мотива. Например, цикл
всех мотивов составляет 24 часа, из которых каждые 6 часов полностью заняты
данными одного из четырёх заданных мотивов. Все мотивы соответствуют различным
значениям {\bf одного и того же} атрибута, причём каждый объект обладает
не более чем одним значением этого атрибута. Такие мотивы гарантированно будут
распознаны алгоритмом и именно на них, предположительно, может быть
приблизительно оценен максимальный прирост алгоритма.

\bigskip

Пример одиночного запуска:
\begin{itemize}
\item Простой LRU~--- 0.503
\item Атрибутивно-сегментный LRU~--- 0.703
\end{itemize}

Результат эксперимента: {\bf положительный}.

\begin{figure}[h]
\centering
	\begin{subfigure}[h]{3in}
		\includegraphics[width=1.0\textwidth]{graph/easy-clean}
	\end{subfigure}
	\begin{subfigure}[h]{3in}
		\includegraphics[width=1.0\textwidth]{graph/easy-noise}
	\end{subfigure}
\caption{Легко разделяемые данные (без шума и с шумом соответственно).}
\label{easy}
\end{figure}

\subsubsection{Легко разделяемые данные с шумом}

Несколько усложнённый вариант предыдущего типа наборов. В этом случае, помимо
данных, соответствующих одному мотиву, к ним добавляется постоянный шум из
случайных объектов, не обладающих каким-либо мотивом. Эта серия экспериментов
проверяет способность алгоритма находить лучший из обнаруженных мотивов.

\bigskip

Пример одиночного запуска:
\begin{itemize}
\item Простой LRU~--- 0.349
\item Атрибутивно-сегментный LRU~--- 0.499
\end{itemize}

Результат эксперимента: {\bf положительный}.

\bigskip

Можно заметить, что, хотя абсолютный BHR снизился в обоих случаях из-за
возросшего абсолютного объёма трафика, в целом сохранились форма кривых, а
также относительный прирост BHR улучшенного алгоритма, который составляет
около $\frac{0.499}{0.349}\approx40\%$.

\subsubsection{Смешанные мотивы}

В следующей серии наборов данных каждому временному слоту соответствует не
один мотив, а несколько, причём в разные моменты времени соотношение между
объёмами каждого из мотивов будет отличаться. Эта серия проверяет способность
алгоритма работать более чем с двумя сегментами значимого размера (порядка
десятков процентов от общего объёма кэша), а также правильно динамически
вычислять оптимальный размер каждого из таких сегментов.

\bigskip

Пример одиночного запуска:
\begin{itemize}
\item Простой LRU~--- 0.517
\item Атрибутивно-сегментный LRU~--- 0.677
\end{itemize}

Результат эксперимента: {\bf положительный}.

\bigskip
\begin{figure}[h]
\centering
	\begin{subfigure}[h]{3in}
		\includegraphics[width=1.0\textwidth]{graph/mixed-clean}
	\end{subfigure}
	\begin{subfigure}[h]{3in}
		\includegraphics[width=1.0\textwidth]{graph/mixed-noise}
	\end{subfigure}
\caption{Данные со смешанными мотивами (без шума и с шумом
соответственно).}
\label{easy}
\end{figure}

\subsubsection{Смешанные мотивы с шумом}

Эта серия отличается от предыдущей добавлением случайного шума к заданным
мотивам, причём количество шума также непостоянно на протяжении времени.

\bigskip

Пример одиночного запуска:
\begin{itemize}
\item Простой LRU~--- 0.516
\item Атрибутивно-сегментный LRU~--- 0.677
\end{itemize}

Результат эксперимента: {\bf положительный}.

\bigskip

В этой серии наборов относительный прирост немногим меньше предыдущей~---
ок. 30\%, однако форма кривых также сохраняется независимо от наличия шума в
потоке данных.

\subsubsection{Сложные данные с шумом}

Последняя, самая высоконагруженная серия экспериментов. В этой серии в каждый
момент
времени присутствуют несколько разных мотивов и случайный шум, причём периоды
различных мотивов не равны между собой.

Это самый сложный пример, наиболее приближенный к реальному поведению клиентов
в сети (при условии, что это поведение соответствует гипотезе существования
мотивов). 

\bigskip

Пример одиночного запуска:
\begin{itemize}
\item Простой LRU~--- 0.239
\item Атрибутивно-сегментный LRU~--- 0.257
\end{itemize}

Результат эксперимента: {\bf положительный}.

\bigskip

Как видно из результата, самые сложные данные ожидаемо наиболее трудны для
алгоритма, тем не менее, он всё ещё показывает стабильный прирост, но в
данном случае лишь на 7,5\%.

\bigskip

\begin{figure}[h]
\centering
	\begin{subfigure}[h]{3in}
		\includegraphics[width=1.0\textwidth]{graph/hard}
	\end{subfigure}
	\begin{subfigure}[h]{3in}
		\includegraphics[width=1.0\textwidth]{graph/random}
	\end{subfigure}
\caption{Сложные данные с шумом и случайные данные соответственно.}
\label{easy}
\end{figure}

\subsubsection{Случайный шум}

Серия экспериментов для проверки наличия мотивов в абсолютно случайных данных.
Конфигурационный файл в этой серии состоит из одного пустого мотива, у которого
период и длина мотива равны, длина атаки равна нулю, а объём задан постоянной
величиной.

\bigskip

Пример одиночного запуска:
\begin{itemize}
\item Простой LRU~--- 0.054
\item Атрибутивно-сегментный LRU~--- 0.023
\end{itemize}

Результат эксперимента: {\bf отрицательный}.

\bigskip

Как и ожидалось, в случайных данных алгоритм не смог найти ни одного мотива,
и даже понизил результат в попытках их вычислить. Это значит, что применение
алгоритма на неподходящих данных даёт даже худший результат, чем
несегментированный алгоритм.

\subsubsection{Примечание о числе запусков}

Как было замечено в формальной постановке задачи, генератор выдаёт разный
результат при каждом запуске на одинаковых входных параметрах, а значит, и
BHR соответствующего эксперимента будет отличаться, поэтому требовалось найти
{\it вероятную верхнюю оценку} BHR с погрешностью не более 0,01 (1\%).

Для проверки разброса значений были проведены 100 тестовых запусков генератора
и подсчёт разброса BHR на обоих алгоритмах. В результате этих тестов разброс
значений составил {\bf не более 0,3\%}, что позволяет с достаточной
уверенностью утверждать, что BHR для одних и тех же параметров генератора {\bf
совпадает с~точностью до 1\%}.

Для большей уверенности, каждый из конфигурационных файлов запускался на
генераторе 3 раза. По итогам экспериментов разброс также не превысил 0,3\%.

%\begin{figure}[h]
%\centering
%\includegraphics[width=0.6\textwidth]{bhr_graph}
%\caption{График BHR (серый~--- базовый, чёрный~--- улучшенный).}
%\label{bhr_graph}
%\end{figure}

\subsection{Результаты экспериментов}

В результате вышеописанных экспериментов для входных данных разной сложности
показан прирост BHR на всех наборах данных, кроме случайного набора.
Относительный прирост BHR составил от 7,5\% до 42\% в зависимости от серии
наборов данных.

Поскольку задачей работы являлось определение существования {\it хотя бы
одного} набора данных, показывающего положительный результат эксперимента,
задача выполнена успешно, положительный результат показан.

\paragraph{Особенность алгоритма}

Если рассмотреть вышеприведённые графики BHR, на всех наборах, кроме
случайного, можно заметить следующую особенность: сначала
некоторое время BHR базового алгоритма превосходит BHR улучшенного, но затем
последний заметно улучшает показатели. Это может быть связано с тем, что на
малой выборке система обучается поначалу неверно, но затем корректирует данные
и далее показывает лучший результат.
%Здесь же стоит заметить, что {\it время
%обучения}~--- число запросов, которые необходимо обработать алгоритму, чтобы
%как минимум сравняться с базовым значением, в целом, тем выше, чем сложнее
%набор данных и чем быстрее происходит чередование доминирующих мотивов.

\newpage
\section{Результаты работы}

В результате работы было показано, что, действительно, существуют такие наборы
данных, на которых разработанный алгоритм кэширования показывает лучший
показатель BHR, чем лежащий в его основе базовый алгоритм.

Также в целом подтвердилась гипотеза, что этот алгоритм показывает прирост
именно на данных, в которых наблюдаются {\it мотивы}: на случайных данных, в
которых мотивы отсутствуют, алгоритм показывает результат ниже базового
алгоритма.

Более полное исследование, включающее определение доли положительных исходов
эксперимента на всём пространстве входных данных и поиск границ признаков,
позволяющих получить положительный результат, выходит за рамки данной работы,
однако, предположительно, для текущей версии алгоритма пригодны данные,
обладающие мотивами с периодом, являющимся делителем заданного периода
алгоритма (т. о. оптимально выбирать период алгоритма как НОК всех мотивов,
которые, предположительно, могут находиться в этих данных), а все остальные
признаки~--- такие, как относительный объём трафика каждого из мотивов,
наличие фонового шума, не обладающего мотивами и другие описанные выше
признаки либо не влияют на работу алгоритма в заметной степени, либо в любом
случае сохраняют ненулевой прирост алгоритма относительно базового.

\newpage
\section{Заключение}

Хотя в данной работе экспериментальная часть строилась на наборах данных из
CDN-сети, сфера применения алгоритма не ограничивается видеофайлами.

Как было описано, алгоритм применим практически к любым примерам данных,
которые обладают какой-либо информацией, которую можно принять за {\it
атрибуты}, например:

\bigskip

\begin{itemize}
\item У видеофайлов~--- информация из CDN, как указано выше;
\item Для инструкций процессора~--- идентификатор процесса;
\item Для сетевого пакета~--- например, правила обработки, идентификатор
приложения и~т.~п.
\end{itemize}

\paragraph{Возможности для улучшения}

Уже сейчас можно назвать направления, в которых можно улучшить созданный
алгоритм:

\begin{itemize}
\item {\bf Динамическое вычисление периода мотива.} Сейчас периоды определяемых
мотивов задаются фиксированным параметром, который подбирается эмпирическим
путём исходя из естественного характера входных данных;
\item {\bf Разные периоды для мотивов.} Опять же, в нынешней версии, период
определяемых мотивов одинаковый для всех сегментов (точнее, алгоритм может
определять мотивы с периодом, являющимся {\bf делителем} заданного параметра).
Например, если длиной периода задана 1 неделя, то алгоритм может определять
мотивы периодом в 1 неделю или, например, 1 день, но не определит мотив с
периодом в 3 дня. С возможностью динамического определения периода мотива
этот период можно подбирать разным для каждого мотива; для этого потребуется
некоторое усложнение системы временных слотов;
\item {\bf Автоматическая фильтрация атрибутов.} В рамках работы для
проведения экспериментов была проведена предварительная фильтрация входных
данных с целью отсечения {\it мусорных атрибутов}~--- т.~е., таких, которые
гарантированно не несут полезной информации (например, технические данные
файла, такие, как формат видеоконтейнера, системный идентификатор файла
и~т.~п.). Можно дополнить алгоритм системой автоматической фильтрации таких
данных (например, исключать из поиска атрибуты, которые какое-то время не
образуют мотива);
\end{itemize}

\newpage
\begin{thebibliography}{0}
\addcontentsline{toc}{section}{\refname}
\bibitem{}
Podlipnig S., Böszörmenyi L.
A survey of Web cache replacement strategies.~//
ACM Computing Surveys. 2003. N 35. P 374--398.

\bibitem{opt}
De Vleeschauwer D., Robinson D.
Optimum Caching Strategies for a Telco CDN.~//
Bell Labs Technical Journal. 2011. N 16. P 115--132.

\bibitem{facebook}
Huang Q., Birman K., Van Renesse R., Lloyd W., Sanjeev K., Li H. C.
An analysis of Facebook photo caching.~//
SOSP '13: Proceedings of the Twenty-Fourth ACM Symposium on Operating
Systems Principles. 2013. P 167--181.

\bibitem{trendlearner}
Figueiredo F., Almeida J., Gonçalves M., Benevenuto F.
TrendLearner: Early Prediction of Popularity Trends of
User Generated Content.~//
Information Sciences. 2014. N 349.

\bibitem{adaptsize}
Berger D. S., Sitaraman R. K., Harchol-Balter M.
AdaptSize: Orchestrating the Hot Object Memory Cache in a
Content Delivery Network.~//
NSDI'17: Proceedings of the 14th USENIX Conference on Networked Systems
Design and Implementation. 2017. P 483--498.

\end{thebibliography}

\appendix

\newpage
\section{Приложение}

\subsection{Исходные коды программного комплекса}

Исходные коды приложений доступны в репозитории GitHub:
\verb^https://github.com/himotokun/scache^.

\bigskip

\begin{figure}[h]
\includegraphics[width=0.3\textwidth]{QR}
\end{figure}

\subsection{Тестовые наборы данных для экспериментов}

Находятся в том же репозитории, что и исходные коды, в подкаталоге
\verb^/examples^. В нём находятся:
\begin{itemize}
\item Конфигурационные файлы, которые использовались для запуска генератора;
\item Примеры готовых наборов данных для запуска симулятора;
\item Таблица соответствия атрибутов и объектов (в формате JSON).
\end{itemize}

\subsection{Руководство по сборке и запуску приложений}

Сборка исходного кода производится в автоматическом режиме командой
\verb^make^.

В результате сборки исходных кодов получаются три приложения~--- \verb^scache^,
\verb^lru^ и \verb^generator^. Первые два приложения~--- симуляторы
соответственно атрибутивно-сегментного кэша и простого кэша LRU. Третье
приложение~--- генератор наборов данных.

Симуляторы требуют для запуска указания параметров в командной строке; полное
их описание можно получить, запустив приложения без параметров.

Генератор может работать в трёх режимах: одиночном, пакетном и интерактивном:
\begin{itemize}
\item В {\it одиночном} режиме генератор создаёт один набор данных на основе
конфигурационного файла, указанного в параметрах командной строки;
\item В {\it пакетном} режиме генератор создаёт множество наборов данных на
основе {\bfseries\itshape пакетного файла}, путь к которому указывается в
параметрах командной строки;
\item В {\it интерактивном} режиме все операции производятся путём ввода
команд в командную строку генератора (список команд выводится при запуске или
вводе команды \verb^help^); запуск в интерактивном режиме производится без
параметров командной строки.
\end{itemize}

Справку по режимам работы и параметрам командной строки можно получить,
запустив приложение с параметром \verb^help^ (напр., \verb^./generator help^).

\end{document}
